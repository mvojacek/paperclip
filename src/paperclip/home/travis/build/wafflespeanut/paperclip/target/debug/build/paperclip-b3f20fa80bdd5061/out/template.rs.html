<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `/home/travis/build/wafflespeanut/paperclip/target/debug/build/paperclip-b3f20fa80bdd5061/out/template.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>template.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../dark.css"><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../light.css" id="themeStyle"><script src="../../../../../../../../../../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../noscript.css"></noscript><link rel="shortcut icon" href="../../../../../../../../../../../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../../../../../../../../../../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../../../../../../../../../../paperclip/index.html'><div class='logo-container'><img src='../../../../../../../../../../../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../../../../../../../../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../../../../../../../../../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../../../../../../../../../../../settings.html"><img src="../../../../../../../../../../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1"> 1</span>
<span id="2"> 2</span>
<span id="3"> 3</span>
<span id="4"> 4</span>
<span id="5"> 5</span>
<span id="6"> 6</span>
<span id="7"> 7</span>
<span id="8"> 8</span>
<span id="9"> 9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
</pre><div class="example-wrap"><pre class="rust ">

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;codegen&quot;</span>)]</span>
<span class="kw">mod</span> <span class="ident">template</span> {
    <span class="kw">use</span> <span class="ident">tinytemplate</span>::<span class="ident">TinyTemplate</span>;

    <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Copy</span>, <span class="ident">Clone</span>)]</span>
    <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">dead_code</span>, <span class="ident">non_camel_case_types</span>)]</span>
    <span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">TEMPLATE</span> {
        <span class="ident">CARGO_MANIFEST</span>,
        <span class="ident">CLIENT_MOD</span>,
        <span class="ident">CLAP_YAML</span>,
        <span class="ident">CLI_MAIN</span>,
    }
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">CARGO_MANIFEST</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;[package]\nname = { name | unescaped }\nversion = { version | unescaped }\nauthors = { authors | unescaped }\nedition = \&quot;2018\&quot;\n{{ if is_cli }}\n[[bin]]\nname = { name | unescaped }\npath = \&quot;main.rs\&quot;\n{{ else }}\n[lib]\npath = \&quot;lib.rs\&quot;\n{{ endif }}\n[dependencies]\nfailure = \&quot;0.1\&quot;\nfutures = \&quot;0.1\&quot;\nparking_lot = \&quot;0.8\&quot;\nreqwest = \&quot;0.9\&quot;\nserde = \&quot;1.0\&quot;\n{{ if is_cli }}\nclap = \\{ version = \&quot;2.33\&quot;, features = [\&quot;yaml\&quot;] }\nenv_logger = \&quot;0.6\&quot;\nfutures-preview = \\{ version = \&quot;0.3.0-alpha.16\&quot;, features = [\&quot;compat\&quot;], package = \&quot;futures-preview\&quot; }\nhumantime = \&quot;1.2\&quot;\nopenssl = \\{ version = \&quot;0.10\&quot;, features = [\&quot;vendored\&quot;] }\nserde_json = \&quot;1.0\&quot;\nruntime = \\{ git = \&quot;https://github.com/rustasync/runtime\&quot; }\nruntime-tokio = \\{ git = \&quot;https://github.com/rustasync/runtime\&quot; }\n{{ endif }}\n[workspace]\n&quot;</span>;

    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">CLIENT_MOD</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;\npub mod client \\{\n    use futures::\\{Future, future};\n    use parking_lot::Mutex;\n\n    /// Common API errors.\n    #[derive(Debug, Fail)]\n    pub enum ApiError \\{\n        #[fail(display = \&quot;API request failed for path: \\{} (code: \\{})\&quot;, _0, _1)]\n        Failure(String, reqwest::StatusCode, Mutex&lt;reqwest::r#async::Response&gt;),\n        #[fail(display = \&quot;An error has occurred while performing the API request: \\{}\&quot;, _0)]\n        Reqwest(reqwest::Error),\n    }\n\n    /// Represents an API client.\n    pub trait ApiClient \\{\n        /// Consumes a method and a relative path and produces a request builder for a single API call.\n        fn request_builder(&amp;self, method: reqwest::Method, rel_path: &amp;str) -&gt; reqwest::r#async::RequestBuilder;\n\n        /// Performs the HTTP request using the given `Request` object\n        /// and returns a `Response` future.\n        fn make_request(&amp;self, req: reqwest::r#async::Request)\n                       -&gt; Box&lt;dyn Future&lt;Item=reqwest::r#async::Response, Error=reqwest::Error&gt; + Send&gt;;\n    }\n\n    impl ApiClient for reqwest::r#async::Client \\{\n        #[inline]\n        fn request_builder(&amp;self, method: reqwest::Method, rel_path: &amp;str) -&gt; reqwest::r#async::RequestBuilder \\{\n            let mut u = String::from(\&quot;{base_url | unescaped}\&quot;);\n            u.push_str(rel_path.trim_start_matches(\&#39;/\&#39;));\n            self.request(method, &amp;u)\n        }\n\n        #[inline]\n        fn make_request(&amp;self, req: reqwest::r#async::Request)\n                       -&gt; Box&lt;dyn Future&lt;Item=reqwest::r#async::Response, Error=reqwest::Error&gt; + Send&gt; \\{\n            Box::new(self.execute(req)) as Box&lt;_&gt;\n        }\n    }\n\n    /// A trait for indicating that the implementor can send an API call.\n    pub trait Sendable \\{\n        /// The output object from this API request.\n        type Output: serde::de::DeserializeOwned + Send + \&#39;static;\n\n        /// HTTP method used by this call.\n        const METHOD: reqwest::Method;\n\n        /// Relative URL for this API call formatted appropriately with parameter values.\n        ///\n        /// **NOTE:** This URL **must** begin with `/`.\n        fn rel_path(&amp;self) -&gt; std::borrow::Cow&lt;\&#39;static, str&gt;;\n\n        /// Modifier for this object. Builders override this method if they\n        /// wish to add query parameters, set body, etc.\n        fn modify(&amp;self, req: reqwest::r#async::RequestBuilder) -&gt; reqwest::r#async::RequestBuilder \\{\n            req\n        }\n\n        /// Sends the request and returns a future for the response object.\n        fn send(&amp;self, client: &amp;dyn ApiClient) -&gt; Box&lt;dyn Future&lt;Item=Self::Output, Error=ApiError&gt; + Send&gt; \\{\n            Box::new(self.send_raw(client).and_then(|mut resp| \\{\n                {deserializer | unescaped}\n            })) as Box&lt;_&gt;\n        }\n\n        /// Convenience method for returning a raw response after sending a request.\n        fn send_raw(&amp;self, client: &amp;dyn ApiClient) -&gt; Box&lt;dyn Future&lt;Item=reqwest::r#async::Response, Error=ApiError&gt; + Send&gt; \\{\n            let rel_path = self.rel_path();\n            let builder = self.modify(client.request_builder(Self::METHOD, &amp;rel_path));\n            let req = match builder.build() \\{\n                Ok(r) =&gt; r,\n                Err(e) =&gt; return Box::new(future::err(ApiError::Reqwest(e))),\n            };\n\n            Box::new(client.make_request(req).map_err(ApiError::Reqwest).and_then(move |resp| \\{\n                if resp.status().is_success() \\{\n                    futures::future::ok(resp)\n                } else \\{\n                    futures::future::err(ApiError::Failure(rel_path.into_owned(), resp.status(), Mutex::new(resp)).into())\n                }\n            })) as Box&lt;_&gt;\n        }\n    }\n}\n&quot;</span>;

    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">CLAP_YAML</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;\nname: { name | unescaped }\nversion: { version | unescaped }\n\nsettings:\n- SubcommandRequiredElseHelp\n\nargs:\n    - ca-cert:\n        long: ca-cert\n        help: Path to CA certificate to be added to trust store.\n        takes_value: true\n    - client-cert:\n        long: client-cert\n        help: Path to certificate for TLS client verification.\n        takes_value: true\n        requires:\n            - client-key\n    - client-key:\n        long: client-key\n        help: Path to private key for TLS client verification.\n        takes_value: true\n        requires:\n            - client-cert\n    - url:\n        long: url\n        help: Base URL for your API.\n        takes_value: true\n        required: true\n    - verbose:\n        short: v\n        long: verbose\n        help: Enable verbose mode.\n    - timeout:\n        short: t\n        long: timeout\n        help: Set the request timeout.\n        takes_value: true\n\nsubcommands:\n&quot;</span>;

    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">CLI_MAIN</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;\nuse self::client::\\{ApiClient, ApiError};\nuse clap::App;\nuse failure::Error;\nuse futures::\\{Future, Stream};\nuse futures_preview::compat::Future01CompatExt;\nuse openssl::pkcs12::Pkcs12;\nuse openssl::pkey::PKey;\nuse openssl::x509::X509;\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\nuse std::time::Duration;\n\n#[derive(Debug, Fail)]\n#[allow(dead_code)]\nenum ClientError \\{\n    #[fail(display = \&quot;Duration parse error: \\{}\&quot;, _0)]\n    Duration(humantime::DurationError),\n    #[fail(display = \&quot;I/O error: \\{}\&quot;, _0)]\n    Io(std::io::Error),\n    #[fail(display = \&quot;OpenSSL error: \\{}\&quot;, _0)]\n    OpenSsl(openssl::error::ErrorStack),\n    #[fail(display = \&quot;Client error: \\{}\&quot;, _0)]\n    Reqwest(reqwest::Error),\n    #[fail(display = \&quot;URL error: \\{}\&quot;, _0)]\n    Url(reqwest::UrlError),\n    #[fail(display = \&quot;\\{}\&quot;, _0)]\n    Api(self::client::ApiError),\n    #[fail(display = \&quot;Payload error: \\{}\&quot;, _0)]\n    Json(serde_json::Error),\n    #[fail(display = \&quot;\&quot;)]\n    Empty,\n}\n\nfn read_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; \\{\n    let mut data = vec![];\n    let mut fd = File::open(path.as_ref()).map_err(ClientError::Io)?;\n    fd.read_to_end(&amp;mut data).map_err(ClientError::Io)?;\n    Ok(data)\n}\n\nstruct WrappedClient \\{\n    verbose: bool,\n    inner: reqwest::r#async::Client,\n    url: reqwest::Url,\n}\n\nimpl ApiClient for WrappedClient \\{\n    fn make_request(&amp;self, req: reqwest::r#async::Request)\n                   -&gt; Box&lt;dyn futures::Future&lt;Item=reqwest::r#async::Response, Error=reqwest::Error&gt; + Send&gt;\n    \\{\n        if self.verbose \\{\n            println!(\&quot;\\{} \\{}\&quot;, req.method(), req.url());\n        }\n\n        self.inner.make_request(req)\n    }\n\n    fn request_builder(&amp;self, method: reqwest::Method, rel_path: &amp;str) -&gt; reqwest::r#async::RequestBuilder \\{\n        let mut u = self.url.clone();\n        let mut path = u.path().trim_matches(\&#39;/\&#39;).to_owned();\n        if !path.is_empty() \\{\n            path = String::from(\&quot;/\&quot;) + &amp;path;\n        }\n\n        path.push_str(rel_path);\n        u.set_path(&amp;path);\n        self.inner.request(method, u)\n    }\n}\n\nfn parse_args_and_fetch()\n    -&gt; Result&lt;(WrappedClient, Box&lt;dyn futures::Future&lt;Item=reqwest::r#async::Response, Error=ApiError&gt; + Send + \&#39;static&gt;), Error&gt;\n\\{\n    let yml = load_yaml!(\&quot;app.yaml\&quot;);\n    let app = App::from_yaml(yml);\n    let matches = app.get_matches();\n    let (sub_cmd, sub_matches) = matches.subcommand();\n\n    let mut client = reqwest::r#async::Client::builder();\n\n    if let Some(p) = matches.value_of(\&quot;ca-cert\&quot;) \\{\n        let ca_cert = X509::from_pem(&amp;read_file(p)?)\n            .map_err(ClientError::OpenSsl)?;\n        let ca_der = ca_cert.to_der().map_err(ClientError::OpenSsl)?;\n        client = client.add_root_certificate(\n            reqwest::Certificate::from_der(&amp;ca_der)\n                .map_err(ClientError::Reqwest)?\n        );\n    }\n\n    // FIXME: Is this the only way?\n    if let (Some(p1), Some(p2)) = (matches.value_of(\&quot;client-key\&quot;), matches.value_of(\&quot;client-cert\&quot;)) \\{\n        let cert = X509::from_pem(&amp;read_file(p2)?).map_err(ClientError::OpenSsl)?;\n        let key = PKey::private_key_from_pem(&amp;read_file(p1)?)\n            .map_err(ClientError::OpenSsl)?;\n        let builder = Pkcs12::builder();\n        let pkcs12 = builder.build(\&quot;foobar\&quot;, \&quot;my-client\&quot;, &amp;key, &amp;cert)\n            .map_err(ClientError::OpenSsl)?;\n        let identity = reqwest::Identity::from_pkcs12_der(\n            &amp;pkcs12.to_der().map_err(ClientError::OpenSsl)?,\n            \&quot;foobar\&quot;\n        ).map_err(ClientError::Reqwest)?;\n        client = client.identity(identity);\n    }\n\n    if let Some(timeout) = matches.value_of(\&quot;timeout\&quot;) \\{\n        let d = timeout.parse::&lt;humantime::Duration&gt;()?;\n        client = client.timeout(d.into());\n    }\n\n    let is_verbose = matches.is_present(\&quot;verbose\&quot;);\n    let url = matches.value_of(\&quot;url\&quot;).expect(\&quot;required arg URL?\&quot;);\n    let client = WrappedClient \\{\n        inner: client.build().map_err(ClientError::Reqwest)?,\n        url: reqwest::Url::parse(url).map_err(ClientError::Url)?,\n        verbose: is_verbose,\n    };\n\n    let f = self::cli::response_future(&amp;client, &amp;matches, sub_cmd, sub_matches)?;\n    Ok((client, f))\n}\n\nasync fn run_app() -&gt; Result&lt;(), Error&gt; \\{\n    let (client, f) = parse_args_and_fetch()?;\n    let response = match f.map_err(ClientError::Api).compat().await \\{\n        Ok(r) =&gt; r,\n        Err(ClientError::Api(ApiError::Failure(_, _, r))) =&gt; r.into_inner(),\n        Err(e) =&gt; return Err(e.into()),\n    };\n\n    let status = response.status();\n    if client.verbose \\{\n        println!(\&quot;\\{}\&quot;, status);\n    }\n\n    let bytes = response\n        .into_body()\n        .concat2()\n        .map_err(ClientError::Reqwest)\n        .compat()\n        .await?;\n\n    let _ = std::io::copy(&amp;mut &amp;*bytes, &amp;mut std::io::stdout());\n    if !status.is_success() \\{\n        Err(ClientError::Empty)?\n    }\n\n    Ok(())\n}\n\n#[runtime::main(runtime_tokio::Tokio)]\nasync fn main() \\{\n    env_logger::init();\n    if let Err(e) = run_app().await \\{\n        println!(\&quot;\\{}\&quot;, e);\n    }\n}\n&quot;</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">render</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>(<span class="ident">t</span>: <span class="ident">TEMPLATE</span>, <span class="ident">context</span>: <span class="kw-2">&amp;</span><span class="ident">C</span>) <span class="op">-&gt;</span> <span class="ident">tinytemplate</span>::<span class="ident">error</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>
        <span class="kw">where</span> <span class="ident">C</span>: <span class="ident">serde</span>::<span class="ident">Serialize</span>
    {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span> <span class="op">=</span> <span class="ident">TinyTemplate</span>::<span class="ident">new</span>();
        <span class="ident">temp</span>.<span class="ident">add_template</span>(<span class="string">&quot;file&quot;</span>, <span class="kw">match</span> <span class="ident">t</span> {
            <span class="ident">TEMPLATE</span>::<span class="ident">CARGO_MANIFEST</span> <span class="op">=&gt;</span> <span class="ident">CARGO_MANIFEST</span>,
            <span class="ident">TEMPLATE</span>::<span class="ident">CLIENT_MOD</span> <span class="op">=&gt;</span> <span class="ident">CLIENT_MOD</span>,
            <span class="ident">TEMPLATE</span>::<span class="ident">CLAP_YAML</span> <span class="op">=&gt;</span> <span class="ident">CLAP_YAML</span>,
            <span class="ident">TEMPLATE</span>::<span class="ident">CLI_MAIN</span> <span class="op">=&gt;</span> <span class="ident">CLI_MAIN</span>,
        })<span class="question-mark">?</span>;

        <span class="ident">temp</span>.<span class="ident">render</span>(<span class="string">&quot;file&quot;</span>, <span class="ident">context</span>)
    }
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../../../../../../../../../../../";window.currentCrate = "paperclip";</script><script src="../../../../../../../../../../../../aliases.js"></script><script src="../../../../../../../../../../../../main.js"></script><script src="../../../../../../../../../../../../source-script.js"></script><script src="../../../../../../../../../../../../source-files.js"></script><script defer src="../../../../../../../../../../../../search-index.js"></script></body></html>